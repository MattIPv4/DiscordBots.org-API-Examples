Author: trigoman#5270 (96802905322962944)
Message: **Language**:  Clojure
**Library**:  JDA
**Code**: 
**project.clj**
```
...
:dependencies [[cheshire "5.8.0"]
                 [clj-http "3.7.0"]
                 [net.dv8tion/JDA "3.4.0_320"]
                 [org.clojure/clojure "1.9.0"]]
  :repositories [["jcenter" "https://jcenter.bintray.com"]]
  ;:jvm-opts ["--add-modules" "java.xml.bind"] ; if using Java 9 uncomment this
```
**core.clj**
```
(ns dbl-server-stats.core
  (:require [cheshire.core :as cheshire]
            [clj-http.client :as client])
  (:gen-class)
  (:import (net.dv8tion.jda.core AccountType JDABuilder JDA)
           (net.dv8tion.jda.core.hooks ListenerAdapter)
           (net.dv8tion.jda.core.events ReadyEvent Event)
           (net.dv8tion.jda.core.events.guild GuildJoinEvent GuildLeaveEvent)))

(defn update-server-stats
  "Sends a POST request with the new server count for the bot-id."
  [bot-id token stats]
  (let [api-url "https://discordbots.org/api/"
        body (cheshire/generate-string stats)
        headers {"Authorization" token}]

    (-> (str api-url "bots/" bot-id "/stats")
        (client/post {:body body
                      :headers headers
                      :content-type :json
                      :accept :json}))))

(defn bot-stats
  "Create stats map from the JDA api object"
  [^Event event]
  {:server_count (-> event
                     .getJDA
                     .getGuildCache
                     .size)})

(defn listener-adapter [bot-id token]
  (proxy [ListenerAdapter] []
    (onReady [event]
      (let [stats (bot-stats event)]
        (println "onReady:" stats)
        (update-server-stats bot-id token stats)))))

(defn -main
  [& args]
  (let [bot-token "discord-api-bot-token"
        bot-id "dbl-bot-id"
        token "dbl-api-token"
        jda (-> AccountType/BOT
              JDABuilder.
              (.setToken bot-token)
              (.addEventListener (object-array [(listener-adapter bot-id token)]))
              .buildBlocking)]))
```

Author: 7coil#3175 (190519304972664832)
Message: **Language:** bash
**Requirements:** `curl`
```bash
#!/bin/bash
USERID=
TOKEN=

curl "https://discordbots.org/api/bots/${USERID}/stats" \
    -i -v \
    -X POST \
    -H "Content-Type: application/json" \
    -H "Authorization: ${TOKEN}" \
    -d '{ "server_count": 10 }'
```

Note: `-i -v` are optional

Author: aetaric#1427 (188105444365959170)
Message: **Language**: Ruby
**Library**: discordrb
**Code**: ```ruby
require 'net/http'
require 'json'

body = {}
body["server_count"] = $bot.servers.count
body["shard_id"] = shard
body["shard_count"] = total_shards

uri = URI.parse("https://discordbots.org/api/bots/#{bot.profile.id}/stats")
request = Net::HTTP::Post.new(uri)
request["Authorization"] = "#{dbl_token}"
request["Content-Type"] = "application/json"
request.body = JSON.dump(body)

req_options = {
  use_ssl: uri.scheme == "https",
}

response = Net::HTTP.start(uri.hostname, uri.port, req_options) do |http|
  http.request(request)
end
```

This example assumes sharding, but uses the native Net::HTTP and JSON modules instead of third party libs.

Author: CircuitRCAY#3326 (255114091360681986)
Message: **Language**: Kotlin
**Libraries**: JDA, OkHTTP
**Code**:
```kotlin
// duncte123's code adapted to Kotlin
val url = "https://discordbots.org/api/bots/${jda.selfuser.id}/stats"
val client = OkHTTPClient()
val data : JSONObject = JSONObject()
data.put("server_count", jda.guilds.size())
val body : RequestBody = RequestBody.create(MediaType.parse("application/json"), data.toString());

val request : Request = RequestBuilder()
    .url(url)
    .post(body)
    .addHeader("Authorization", bot_key_here)
    .build()
try {
    client().newCall(request).execute()
} catch (e: Exception) {
    e.printStackTrace();
}
```

Author: IPv4#6434 (193060889111298048)
Message: **Language:** PHP
**Library:** N/A
**Code:**
```php
$GUILDCOUNT = 10;
$BOTID = "1234567890";
$AUTH = "somereallylongapiauthcodefromdbl";

$dblData = ["server_count"=>$GUILDCOUNT];
$dblData = json_encode($dblData);
$dblURL = "https://discordbots.org/api/bots/".$BOTID."/stats";

$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $dblURL);
curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_POST, 1);
curl_setopt($ch, CURLOPT_POSTFIELDS, $dblData);
curl_setopt($ch, CURLOPT_HTTPHEADER, array(
    'Authorization: '.$AUTH,
    'Content-Type: application/json'
));
$result = curl_exec($ch);
curl_close($ch);
```

Author: spong#3338 (87164639695110144)
Message: **Language:** Clojure
**Code:**
project.clj
```clj
:dependencies [[org.json/json "20171018"]
               [com.squareup/okhttp3 "3.9.1"]]
```
dbl.clj
```clj
(ns myproject.dbl
    (:gen-class)
    (:import 
        [org.json JSONObject]
        [com.squareup.okhttp3 OkHttpClient RequestBody MediaType Request]))

(def client (OkHttpClient.))

(defn updateStats [userId, token, servers]
    (def url (str "https://discordbots.org/api/bots/" userId "/stats"))
    
    (def data (-> (JSONObject.)
        (.put "server_count" servers)
        .toString))

    (def body (-> (RequestBody/create (MediaType/parse "application/json") data)))

    (def request (-> (Request/Builder.) 
        (.url url)
        (.post body)
        (.addHeader "Authorization" token)
        .build))

    (-> (client) (.newCall request) .execute))
```
usage:
```clj
(updateStats "bot user id" "auth token" servercount)
```

Author: spong#3338 (87164639695110144)
Message: **Language**: Crystal
**Library**: No specific discord library code but atm the only lib is discord.cr
**Code**:
```crystal
require "http/client"
require "json"

token = "dab" # your discordbots.org token
count = 52 # the number of servers your bot is in

headers = HTTP::Headers{"Authorization" => token}

body = {"server_count" => count}.to_json

HTTP::Client.post("https://discordbots.org/api/bots/stats", headers: headers, body: body) do |res|
  status = res.status_code

  if status != 200
    puts "Uh oh! Stats update responded with status #{status}!"
  end
end
```

Author: Habchy#1665 (162780049869635584)
Message: **Language**: AutoHotKey
**Library**: AHK4Discord by Habchy [<:soontm:230160205479018498>]
**Code**:

```autohotkey
;remove maximus and put your bot name
botname = Maximus

Gui, poster:Color, 0x3cb1f9
Gui, poster:Add, Text, x5 y5 w95 h15, %botname% API Poster
Gui, poster:Add, Text, x5 y20 w95 h15, Made by Habchy
Gui, poster:Add, Text, x5 y35 w60 h15, Version 1.3
Gui, poster:Add, Button, x150 y5 w195 h40 gmaxistart, Post
Gui, poster:Show, w349 h49, API Poster
return

posterGuiClose:
goto exiting

maxistart:
serverfile = %A_Temp%\servercount.txt
FileDelete %A_Temp%\servercount.txt
MsgBox, 64, API Poster, API Poster will launch in 3 seconds.,3

InputBox, servers, Server Count Poster, How many servers is %botname% on?
Sleep, 2000
InputBox, shards, Server Shard Poster, How many shards is %botname% on?
Sleep, 2000

FileAppend,
(
{
  "server_count": %servers%,
  "shard_id": 0,
  "shard_count": %shards%
}
), %serverfile%
FileRead, Max, %A_Temp%\servercount.txt

WinHTTP := ComObjCreate("WinHTTP.WinHttpRequest.5.1")
;~ WinHTTP.SetProxy(0)
WinHTTP.Open("POST", "https://discordbots.org/api/bots/YOUR BOTS CLIENT ID/stats", 0)
WinHTTP.SetRequestHeader("Authorization", "YOUR API TOKEN FOR YOUR BOT")
WinHTTP.SetRequestHeader("Content-Type", "application/json")
;linebreak---------------------
WinHTTP.Send(Max)
Result := WinHTTP.ResponseText
Status := WinHTTP.Status

msgbox % "status: " status "`n`nresult: " result
return

exiting:
F4::
MsgBox, 64, API Poster, Shutting down. Goodbye! ðŸ‘‹,2
ExitApp
```

<:no1:341047443149946884> Don't rely on this. Use it until you know how to emplement one of the other automatic ones. Also don't fake server count.

Author: Shengaero#9090 (211393686628597761)
Message: **Language:** Kotlin
**Library:** JDA (no KJDA required)
**Code:** ```kotlin
val client: OkHttpClient = /* your client */

 // This is not a standard function with OkHttp, see the code below
client.newRequest {
    post(RequestBody.create(Requester.MEDIA_TYPE_JSON, body.toString()))
    url("https://discordbots.org/api/bots/${jda.selfUser.id}/stats")
    header("Authorization", YOUR_API_KEY_HERE)
    header("Content-Type", "application/json")
}.enqueue(object : Callback {
    override fun onResponse(call: Call, response: Response) = response.close()

    override fun onFailure(call: Call, e: IOException) {
        Client.log.fatal("Failed to send information to discordbots.org")
        Client log e
    }
})

// I use this extension for readability but it's not necessary 
private inline fun OkHttpClient.newRequest(lazy: Request.Builder.() -> Unit) : Call {
    val builder = Request.Builder()
    builder.lazy()
    return this.newCall(builder.build())
}```

Author: spong#3338 (87164639695110144)
Message: **Language**: Golo (with OkHttp)
**Library**: JDA
**Code**:
```golo
let discordbotsToken = "YOUR DISCORDBOTS.ORG TOKEN"

let client = OkHttpClient()
let jsonMediaType = MediaType.parse("application/json")

function sendStats = |jda| {
    let payload = JSONObject():
        put("server_count", jda: getGuilds(): size())
        
    let info = jda: getShardInfo()
    if (info != null) {
        payload:
            put("shard_id", info: getShardId()):
            put("shard_count", info: getShardTotal())
    }
    
    let body = RequestBody.create(jsonMediaType, payload: toString())
    
    let request = Request.Builder():
        url("https://discordbots.org/api/bots/" + jda: getSelfUser(): getId() + "/stats"):
        addHeader("Authorization", discordbotsToken):
        post(body):
        build()
    
    client: newCall(request): execute()
}
```

Author: iDerp#3616 (159074350350336000)
Message: **Language**: C#
**Library**: DSharpPlus
**Code**: 
```cs
HttpClient client = new HttpClient();
            HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Post, "https://discordbots.org/api/bots/<BotID>/stats");
            string json = JsonConvert.SerializeObject(new { server_count = e.Client.Guilds.Count, shard_id = e.Client.ShardId, shard_count = e.Client.ShardCount });
            request.Content = new StringContent(json);
            request.Content.Headers.ContentType = new MediaTypeHeaderValue("application/json");
            request.Headers.Add("Authorization", "<Token>");
            HttpResponseMessage message = await client.SendAsync(request);
            client.Dispose();
```

Author: spong#3338 (87164639695110144)
Message: **Language**: Rust (async with hyper)
**Code**:
```toml
hyper = "0.11.0"
hyper-tls = "0.1.0"
tokio-core = "0.1"
futures = "0.1.14"
```
```rust
extern crate hyper;
extern crate hyper_tls;
extern crate tokio_core;
extern crate futures;

use hyper::{Client, Request, Method};
use hyper::header::ContentType;
use hyper_tls::HttpsConnector;
use tokio_core::reactor::Core;
use futures::Future;

fn main() {
    let client_id: &str;   // bot client id
    let server_count: i32; // server count
    let api_token: &str;   // discordbots.org api token

    // a new tokio core instance, this works as an event loop so obviously you should not create a new instance every time stats are posted
    let mut core = Core::new().unwrap();
    let handle = core.handle();
    let client = Client::configure()
        .connector(HttpsConnector::new(4, &handle).unwrap())
        .build(&handle);

    let uri = format!("https://discordbots.org/api/bots/{}/stats", client_id).parse()
        .expect("could not parse uri");
    let json = format!(r#"{{"server_count":{}}}"#, server_count);

    let mut req = Request::new(Method::Post, uri);
    req.headers_mut().set_raw("Authorization", api_token);
    req.headers_mut().set(ContentType::json());
    req.set_body(json);

    let task = client.request(req).map(|res| {
        println!("Status: {}", res.status());
    });
    core.run(task).expect("an error occurred when sending a request!");
}
```

Author: Neo#5159 (223754830747926528)
Message: **Language**: Neo
**Library**: discord.neo
**Code**: 
```neo
from neo ; import discordbots.org


link neo is: https://discordbots.org/api/bots/&&BOT_ID_CLIENT&&/stats

neo define(neo, bot, link)::
send = next.link.send.info === (&&SERVER_COUNT_BOT_CLIENT%%$&&(link join neo_libary.link))
join_server = 
bot_client&&send&&
leave server = 
bot_client&&send&&```

Author: Tomâ„¢#7887 (248294452307689473)
Message: **Language:** lua
```lua
local http = require("socket.http")
local ltn12 = require("ltn12")

function sendRequest()
local path = "https://discordbots.org/api/bots/YOURBOTID/stats"
  local payload = [[ {"servers":"count","shard_id":"shardid","shard_count":"shardcount"} ]]
  local res, code, response_headers, status = http.request
  {
    url = path,
    method = "POST",
    headers =
    {
      ["Authorization"] = "YOURKEY", 
      ["Content-Type"] = "application/json"
    },
    source = ltn12.source.string(payload), }
end```
**note**: never used lua a day in my life but should work Â¯\_(ãƒ„)_/Â¯

Author: spong#3338 (87164639695110144)
Message: **Language**: Go
**Code**:
```go
import (
    "fmt"
    "net/http"
    "bytes"
)

type statsForm struct {
    ServerCount int `json:"server_count"`
    // if you use sharding just add more fields here
}

var (
    stats statsForm
    clientId  string
    authToken string
)

func stats() {
    body, err := json.Marshal(&stats)
    if err != nil {
        fmt.Println("Oh no! An error!", err);
        return;
    }
    client := &http.Client{}
    req, err := http.NewRequest("POST", "https://discordbots.org/api/bots/" + clientId + "/stats", bytes.NewBuffer(body))
    if err != nil {
        fmt.Println("Oh no! An error!", err);
        return;
    }
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", authToken)
    _, err = client.Do(req)
    if err != nil {
        fmt.Println("Oh no! An error!", err)
        return
    }
}
```

Author: Snazzah#0371 (158049329150427136)
Message: **Language**: Ruby
**Library**: discordrb
**Code**: 
```rb
bot = Discordrb::Commands::CommandBot.new(token: token, prefix: ['your_prefix_here'])
RestClient.post("https://discordbots.org/api/bots/#{bot.bot_user.id}/stats", '{"server_count":'+bot.servers.count+'}', :'Authorization' => "DBOTS_TOKEN", :'Content-Type' => :json);
```

Author: Erlite#2215 (244165871562391552)
Message: **Language:** C#
**Library:** Discord.NET
**Code:**
```cs
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using (var webclient = new HttpClient())
using (var content = new StringContent($"{{ \"server_count\": {client.Guilds.Count}}}", Encoding.UTF8, "application/json"))
{
    webclient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("token");
    HttpResponseMessage response = await webclient.PostAsync("https://discordbots.org/api/bots/YOUR_BOT_ID_HERE/stats", content);
}
```

**Client is your DiscordSocketClient**
